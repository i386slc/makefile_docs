# Необычные правила

## Неявные правила

Make любит компиляцию C. И каждый раз, когда он выражает свою любовь, все становится запутанным. Возможно, самая запутанная часть Make — это создаваемые магические/автоматические правила. Make называет эти «неявные» (**implicit**) правила. Я лично не согласен с этим дизайнерским решением и не рекомендую их использовать, но они часто используются, и поэтому их полезно знать. Вот список неявных правил:

* Компиляция программы на C: `n.o` автоматически создается из `n.c` командой вида `$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@`
* Компиляция программы на C++: `n.o` создается автоматически из `n.cc` или `n.cpp` командой вида `$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@`
* Связывание одного объектного файла: `n` создается автоматически из `n.o` запуском команды `$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@`

Важные переменные, используемые неявными правилами:

* **CC**: Программа для компиляции программ на C; по умолчанию **cc**
* **CXX**: Программа для компиляции программ на C++; по умолчанию **g++**
* **CFLAGS**: Дополнительные флаги для компилятора C
* **CXXFLAGS**: дополнительные флаги для компилятора C++.
* **CPPFLAGS**: дополнительные флаги для препроцессора C.
* **LDFLAGS**: дополнительные флаги для компиляторов, когда они должны вызывать компоновщик.

Давайте посмотрим, как теперь мы можем построить программу на C, даже не сообщая Make явно, как выполнять компиляцию:

```makefile
CC = gcc # Флаг для неявных правил
CFLAGS = -g # Флаг неявных правил. Включить отладочную информацию

# Неявное правило #1: blah создается с помощью неявного правила компоновщика C
# Неявное правило #2: blah.o строится с помощью неявного правила компиляции C,
# потому что blah.c существует
blah: blah.o

blah.c:
	echo "int main() { return 0; }" > blah.c

clean:
	rm -f blah*
```

## Статические правила шаблона

## Статические шаблоны правил и фильтры

## Правила шаблона

## Правила двойного двоеточия
