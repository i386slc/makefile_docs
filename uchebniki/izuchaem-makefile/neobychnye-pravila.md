# Необычные правила

## Неявные правила

Make любит компиляцию C. И каждый раз, когда он выражает свою любовь, все становится запутанным. Возможно, самая запутанная часть Make — это создаваемые магические/автоматические правила. Make называет эти «неявные» (**implicit**) правила. Я лично не согласен с этим дизайнерским решением и не рекомендую их использовать, но они часто используются, и поэтому их полезно знать. Вот список неявных правил:

* Компиляция программы на C: `n.o` автоматически создается из `n.c` командой вида `$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@`
* Компиляция программы на C++: `n.o` создается автоматически из `n.cc` или `n.cpp` командой вида `$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@`
* Связывание одного объектного файла: `n` создается автоматически из `n.o` запуском команды `$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@`

Важные переменные, используемые неявными правилами:

* **CC**: Программа для компиляции программ на C; по умолчанию **cc**
* **CXX**: Программа для компиляции программ на C++; по умолчанию **g++**
* **CFLAGS**: Дополнительные флаги для компилятора C
* **CXXFLAGS**: дополнительные флаги для компилятора C++.
* **CPPFLAGS**: дополнительные флаги для препроцессора C.
* **LDFLAGS**: дополнительные флаги для компиляторов, когда они должны вызывать компоновщик.

Давайте посмотрим, как теперь мы можем построить программу на C, даже не сообщая Make явно, как выполнять компиляцию:

```makefile
CC = gcc # Флаг для неявных правил
CFLAGS = -g # Флаг неявных правил. Включить отладочную информацию

# Неявное правило #1: blah создается с помощью неявного правила компоновщика C
# Неявное правило #2: blah.o строится с помощью неявного правила компиляции C,
# потому что blah.c существует
blah: blah.o

blah.c:
	echo "int main() { return 0; }" > blah.c

clean:
	rm -f blah*
```

## Статические правила шаблона

Правила статического шаблона — это еще один способ меньше писать в Makefile, но я бы сказал, что они более полезны и менее «магические». Вот их синтаксис:

```makefile
targets...: target-pattern: prereq-patterns ...
   commands
```

Суть в том, что заданная цель **target** сопоставляется с целевым шаблоном **target-pattern** (через подстановочный знак `%`). То, что было сопоставлено, называется основой **stem**. Затем основа заменяется шаблоном **prereq-pattern**, чтобы сгенерировать пререквизиты цели.

Типичным вариантом использования является компиляция файлов `.c` в файлы `.o`. Вот ручной способ:

```makefile
objects = foo.o bar.o all.o
all: $(objects)

# Эти файлы компилируются по неявным правилам
foo.o: foo.c
bar.o: bar.c
all.o: all.c

all.c:
	echo "int main() { return 0; }" > all.c

%.c:
	touch $@

clean:
	rm -f *.c *.o all
```

Вот более **эффективный** способ, использующий правило статического шаблона:

```makefile
objects = foo.o bar.o all.o
all: $(objects)

# Эти файлы компилируются по неявным правилам
# Синтаксис - targets ...: target-pattern: prereq-patterns ...
# В случае первой цели, foo.o, целевой шаблон соответствует foo.o
# и устанавливает "stem" как "foo".
# Затем он заменяет «%» в prereq-patterns этой основой stem.
$(objects): %.o: %.c

all.c:
	echo "int main() { return 0; }" > all.c

%.c:
	touch $@

clean:
	rm -f *.c *.o all
```

## Статические шаблоны правил и фильтры

Позже я расскажу о функциях, но я предскажу, что вы можете с ними делать. Функцию **filter** можно использовать в правилах статического шаблона для сопоставления правильных файлов. В этом примере я создал расширения `.raw` и `.result`.

```makefile
obj_files = foo.result bar.o lose.o
src_files = foo.raw bar.c lose.c

all: $(obj_files)
# Примечание: PHONY здесь важны. Без него неявные правила попытаются построить
# исполняемый файл «all», поскольку предварительные требования представляют собой
# файлы «.o».
.PHONY: all 

# Пример 1: Файлы .o зависят от файлов .c. Хотя на самом деле мы не делаем файл .o.
$(filter %.o,$(obj_files)): %.o: %.c
	echo "target: $@ prereq: $<"

# Пример 2: Файлы .result зависят от файлов .raw.
# Хотя на самом деле мы не делаем файл .result.
$(filter %.result,$(obj_files)): %.result: %.raw
	echo "target: $@ prereq: $<" 

%.c %.raw:
	touch $@

clean:
	rm -f $(src_files)
```

## Правила шаблона

Шаблонные правила используются часто, но довольно запутанно. Вы можете смотреть на них двумя способами:

* Способ определения собственных неявных правил
* Более простая форма правил статического шаблона

Сначала начнем с примера:

```makefile
# Определите правило шаблона, которое компилирует каждый файл .c в файл .o.
%.o : %.c
		$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
```

Правила шаблона содержат `'%'` в цели. Этот `'%'` соответствует любой непустой строке, а остальные символы соответствуют самим себе. `'%'` в пререквизите шаблонного правила означает ту же основу, которая соответствует `'%'` в цели.

Вот еще один пример:

```makefile
# Определите шаблонное правило, не имеющее шаблона в предварительных требованиях.
# Это просто создает пустые файлы .c, когда это необходимо.
%.c:
   touch $@
```

## Правила двойного двоеточия

Правила с двойным двоеточием используются редко, но позволяют определить несколько правил для одной и той же цели. Если бы это были одиночные двоеточия, было бы напечатано предупреждение и был бы запущен только второй набор команд.

```makefile
all: blah

blah::
	echo "hello"

blah::
	echo "hello again"
```
