# Другие особенности

## Включить Makefile (include)

Директива **include** сообщает make прочитать один или несколько других make-файлов. Это строка в make-файле, которая выглядит так:

```makefile
include filenames...
```

Это особенно полезно, когда вы используете такие флаги компилятора, как `-M`, которые создают файлы Makefile на основе исходного кода. Например, если некоторые файлы c содержат заголовок, этот заголовок будет добавлен в Makefile, написанный **gcc**. Я рассказываю об этом больше в поваренной книге Makefile.

## Директива vpath

Используйте **vpath**, чтобы указать, где существует некоторый набор предварительных условий. Формат: `vpath <pattern> <directories, space/colon separated>` .

`<pattern>` может иметь `%`, который соответствует любому нулю или более символов. Вы также можете сделать это глобально с помощью переменной **VPATH**

```makefile
vpath %.h ../headers ../other-directory

# Примечание: vpath позволяет найти blah.h,
# даже если blah.h никогда не находится в текущем каталоге.
some_binary: ../headers blah.h
	touch some_binary

../headers:
	mkdir ../headers

# Мы вызываем цель blah.h вместо ../headers/blah.h,
# потому что это предварительное требование, которое ищет some_binary.
# Как правило, blah.h уже существует, и вам это не понадобится.
blah.h:
	touch ../headers/blah.h

clean:
	rm -rf ../headers
	rm -f some_binary
```

## Многострочность

Символ обратной косой черты (`"\"`) дает нам возможность использовать несколько строк, когда команды слишком длинные.

```makefile
some_file: 
	echo This line is too long, so \
		it is broken up into multiple lines
```

## .phony

Добавление `.PHONY` к цели не позволит Make перепутать фальшивую цель с именем файла. В этом примере, если файл **clean** создан, `make clean` все равно будет запущен. Технически я должен был использовать его в каждом примере с **all** или **clean**, но я этого не сделал, чтобы сохранить чистоту примеров. Кроме того, фальшивые phony-цели обычно имеют имена, которые редко являются именами файлов, и на практике многие люди пропускают это.

```makefile
some_file:
	touch some_file
	touch clean

.PHONY: clean
clean:
	rm -f some_file
	rm -f clean
```

## .delete\_on\_error

Инструмент make прекратит выполнение правила (и вернется к предварительным требованиям), если команда возвращает ненулевой статус выхода. **DELETE\_ON\_ERROR** удалит цель правила, если правило не работает таким образом. Это произойдет для всех целей, а не только для той, что была раньше, как **PHONY**. Рекомендуется всегда использовать это, даже если make не использует его по историческим причинам.

```makefile
.DELETE_ON_ERROR:
all: one two

one:
	touch one
	false

two:
	touch two
	false
```
