# Приступаем к работе

## Почему существуют Makefiles?

Makefiles используются, чтобы решить, какие части большой программы необходимо перекомпилировать. В подавляющем большинстве случаев компилируются файлы C или C++. Другие языки обычно имеют свои собственные инструменты, которые служат той же цели, что и Make. Make также можно использовать вне компиляции, когда вам нужно запустить серию инструкций в зависимости от того, какие файлы были изменены. В этом руководстве основное внимание будет уделено варианту использования компиляции C/C++.

Вот пример графа зависимостей, который вы можете построить с помощью Make. Если какие-либо зависимости файла изменятся, файл будет перекомпилирован:

<figure><img src="../../.gitbook/assets/dependency_graph.png" alt=""><figcaption></figcaption></figure>

## Какие есть альтернативы Make?

Популярными альтернативными системами сборки C/C++ являются [SCons](https://scons.org/), [CMake](https://cmake.org/), [Bazel](https://bazel.build/) и [Ninja](https://ninja-build.org/). Некоторые редакторы кода, такие как [Microsoft Visual Studio](https://visualstudio.microsoft.com/), имеют собственные встроенные инструменты сборки. Для Java есть [Ant](https://ant.apache.org/), [Maven](https://maven.apache.org/what-is-maven.html) и [Gradle](https://gradle.org/). Другие языки, такие как Go и Rust, имеют свои собственные инструменты сборки.

Интерпретируемые языки, такие как Python, Ruby и Javascript, не требуют аналога Makefile. Цель Makefiles состоит в том, чтобы скомпилировать все файлы, которые необходимо скомпилировать, на основе того, какие файлы были изменены. Но когда файлы на интерпретируемых языках изменяются, ничего не нужно перекомпилировать. При запуске программы используется самая последняя версия файла.

## Версии и типы Make

Существует множество реализаций Make, но большая часть этого руководства будет работать с любой версией, которую вы используете. Однако он специально написан для GNU Make, который является стандартной реализацией в Linux и MacOS. Все примеры работают для версий Make 3 и 4, которые почти эквивалентны, за исключением некоторых эзотерических отличий.

## Запуск примеров

Для запуска этих примеров вам понадобится терминал и установленный make. Для каждого примера поместите содержимое в файл с именем **Makefile** и в этом каталоге запустите команду make. Начнем с самого простого из Makefile:

```makefile
hello:
	echo "Hello, World"
```

{% hint style="info" %}
Makefiles **должны** иметь отступ с использованием **TAB**, а не пробелов, иначе **make** не сработает.
{% endhint %}

Вот результат выполнения приведенного выше примера:

```bash
$ make
echo "Hello, World"
Hello, World
```

Вот и все! Если вы немного запутались, [вот видео](https://youtu.be/zeEMISsjO38), в котором рассматриваются эти шаги, а также описывается базовая структура файлов Makefile.

## Синтаксис Makefile

Makefile состоит из набора правил. Обычно правило выглядит так:

```makefile
targets: prerequisites
	command
	command
	command
```

* **targets** - Целями являются имена файлов, разделенные пробелами. Как правило, на каждое правило приходится только одна цель.
* **commands** - Команды представляют собой серию шагов, обычно используемых для создания целей. Они должны начинаться с символа табуляции, а не пробелов.
* **prerequisites** - Необходимыми условиями также являются имена файлов, разделенные пробелами. Эти файлы должны существовать до запуска команд для цели. Их также называют зависимостями.

## Суть Make

Начнем с примера hello world:

```makefile
hello:
	echo "Hello, World"
	echo "This line will always print, because the file hello does not exist."
```

Здесь уже есть что взять. Давайте разберем это:

* У нас есть одна цель **target** под названием hello
* Эта цель имеет две команды (**commands**)
* Эта цель не имеет предпосылок (**prerequisites**)

Затем мы запускаем `make hello`. Пока файл **hello** не существует, команды будут выполняться. Если **hello** существует, никакие команды выполняться не будут.

Важно понимать, что я говорю о **hello** как о цели (_target_), так и о файле (_file_). Это потому, что они напрямую связаны друг с другом. Как правило, когда цель запускается (то есть, когда запускаются команды цели), команды создают файл с тем же именем, что и цель. В этом случае цель hello не создает файл hello.

Давайте создадим более типичный Makefile, который компилирует один C-файл. Но прежде чем мы это сделаем, создайте файл с именем `blah.c` со следующим содержимым:

```c
// blah.c
int main() { return 0; }
```

Затем создайте Makefile (как всегда, `Makefile`):

```makefile
blah:
	cc blah.c -o blah
```

На этот раз попробуйте просто запустить **make**. Поскольку цель не указана в качестве аргумента команды **make**, запускается _**первая цель**_. В этом случае есть только одна цель (blah). При первом запуске будет создано `blah`. Во второй раз вы увидите `make: 'blah' is up to date`. Это потому, что файл blah уже существует. Но есть проблема: если мы изменим `blah.c`, а затем запустим make, ничего не будет перекомпилировано.

Мы решаем это, добавляя предварительное условие (_prerquisites_):

```makefile
blah: blah.c
	cc blah.c -o blah
```

Когда мы снова запускаем **make**, происходит следующий набор шагов:

* Выбрана первая цель, поскольку первая цель является целью по умолчанию.
* Здесь есть предварительное условие `blah.c`
* Make решает, следует ли запускать цель blah. Он будет работать только в том случае, если blah не существует или `blah.c` новее, чем blah.

Этот последний шаг имеет решающее значение и **является сутью make**. Что он пытается сделать, так это решить, изменились ли предпосылки blah с момента последней компиляции blah. То есть, если `blah.c` изменен, запуск make должен перекомпилировать файл. И наоборот, если `blah.c` не изменился, то и перекомпилировать его не надо.

Чтобы это произошло, он использует временные метки файловой системы в качестве прокси, чтобы определить, изменилось ли что-то. Это разумная эвристика, потому что временные метки файлов обычно меняются только при изменении файлов. Но важно понимать, что это не всегда так. Вы можете, например, изменить файл, а затем изменить временную метку этого файла на что-то старое. Если бы вы это сделали, Make неправильно предположила бы, что файл не изменился, и поэтому его можно было бы проигнорировать.

Уф, какой глоток. **Убедитесь, что вы понимаете это. Это суть Makefiles, и вам может потребоваться несколько минут, чтобы правильно понять**. Поэкспериментируйте с приведенными выше примерами или посмотрите видео выше, если все еще неясно.

## Больше быстрых примеров

Следующий Makefile в конечном итоге запускает все три цели. Когда вы запускаете команду make в терминале, она создает программу под названием blah в несколько шагов:

* Make выбирает цель **blah**, потому что первая цель является целью по умолчанию
* blah требует `blah.o`, так что make ищет цель `blah.o`
* **blah.o** требует `blah.c`, поэтому выполняется поиск цели `blah.c`
* `blah.c` не имеет зависимостей, поэтому выполняется команда **echo**
* Затем запускается команда `cc -c`, потому что все зависимости `blah.o` завершены.
* Выполняется команда `top cc`, потому что все blah-зависимости завершены
* Вот и все: blah — это скомпилированная программа на C

```makefile
blah: blah.o
	cc blah.o -o blah # Запускается третьей

blah.o: blah.c
	cc -c blah.c -o blah.o # Запускается второй

# Обычно blah.c уже существует,
# но я хочу ограничить любые дополнительные необходимые файлы
blah.c:
	echo "int main() { return 0; }" > blah.c # Запускается первой
```

Если вы удалите `blah.c`, все три цели будут запущены повторно. Если вы отредактируете его (и таким образом измените метку времени на более новую, чем `blah.o`), будут запущены первые две цели. Если вы запустите `touch blah.o` (и, таким образом, измените метку времени на более новую, чем blah), то будет запущена только первая цель. Если вы ничего не измените, ни одна из целей не будет запущена. Попробуйте!

Следующий пример не делает ничего нового, но тем не менее является хорошим дополнительным примером. Он всегда будет запускать обе цели, потому что **some\_file** зависит от **other\_file**, который никогда не создается.

```makefile
some_file: other_file
	echo "This will always run, and runs second"
	touch some_file

other_file:
	echo "This will always run, and runs first"
```

## Make clean

**clean** часто используется как цель, которая удаляет вывод других целей, но это _не специальное слово_ в Make. Вы можете запустить `make` и `make clean`, чтобы создать и удалить файл **some\_file**.

Обратите внимание, что **clean** делает здесь две новые вещи:

* Это цель, которая не является первой (по умолчанию) и не является пререквизитом. Это означает, что она никогда не запустится, если вы явно не вызовете `make clean`
* Это не должно быть именем файла. Если у вас есть файл с именем **clean**, эта цель не будет работать, а это не то, что нам нужно. См. `.PHONY` далее в этом руководстве, чтобы узнать, как это исправить.

```makefile
some_file: 
	touch some_file

clean:
	rm -f some_file
```

## Переменные

Переменные могут быть только строками. Обычно вы хотите использовать `:=`, но `=` также работает. См. Переменные, часть 2.

Вот пример использования переменных:

```makefile
files := file1 file2
some_file: $(files)
	echo "Look at this variable: " $(files)
	touch some_file

file1:
	touch file1
file2:
	touch file2

clean:
	rm -f file1 file2 some_file
```

_**Одинарные или двойные кавычки не имеют значения для Make**_. Это просто символы, которые присваиваются переменной. Однако кавычки полезны для `shell/bash`, и они нужны вам в таких командах, как `printf`. В этом примере две команды ведут себя одинаково:

```makefile
a := one two # a устанавливается в строку "one two"
b := 'one two' # Не рекомендуется. b устанавливается в строку "'one two'"
all:
	printf '$a'
	printf $b
```

Ссылка на переменные с помощью `${}` или `$()`

```makefile
x := dude

all:
	echo $(x)
	echo ${x}

	# Плохая практика, но работает
	echo $x 
```
